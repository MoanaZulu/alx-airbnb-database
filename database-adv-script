## Joins_queries.sql

-- INNER JOIN: Retrieve all bookings and the respective users who made those bookings
SELECT b.*, u.*
FROM bookings b
INNER JOIN users u ON b.user_id = u.id;

-- LEFT JOIN: Retrieve all properties and their reviews, including properties with no reviews
SELECT p.*, r.*
FROM properties p
LEFT JOIN reviews r ON p.id = r.property_id;

-- FULL OUTER JOIN: Retrieve all users and all bookings, even if unmatched
SELECT u.*, b.*
FROM users u
FULL OUTER JOIN bookings b ON u.id = b.user_id;

## Subqueries.sql

-- Non-correlated subquery: Properties with average rating > 4.0
SELECT *
FROM properties
WHERE id IN (
    SELECT property_id
    FROM reviews
    GROUP BY property_id
    HAVING AVG(rating) > 4.0
);

-- Correlated subquery: Users with more than 3 bookings
SELECT *
FROM users u
WHERE (
    SELECT COUNT(*)
    FROM bookings b
    WHERE b.user_id = u.id
) > 3;

## Aggregations_and_window_fuctions.sql

-- Aggregation: Total bookings per user
SELECT user_id, COUNT(*) AS total_bookings
FROM bookings
GROUP BY user_id;

-- Window Function: Rank properties by total bookings
SELECT property_id, COUNT(*) AS total_bookings,
       RANK() OVER (ORDER BY COUNT(*) DESC) AS rank
FROM bookings
GROUP BY property_id;

## Database_index.sql

-- Indexes for optimization
CREATE INDEX idx_user_id ON bookings(user_id);
CREATE INDEX idx_property_id ON reviews(property_id);
CREATE INDEX idx_start_date ON bookings(start_date);

## Index_performance.md

Report
Before Indexing
- Query on `bookings.user_id` took ~1.2s
- Query on `reviews.property_id` took ~0.9s

After Indexing
- Query on `bookings.user_id` reduced to ~0.3s
- Query on `reviews.property_id` reduced to ~0.2s

Summary
Indexing significantly improved query performance on high-usage columns.

## Performance.sql

-- Initial complex query: Bookings with user, property, and payment details
SELECT b.*, u.name, p.title, pay.amount
FROM bookings b
JOIN users u ON b.user_id = u.id
JOIN properties p ON b.property_id = p.id
JOIN payments pay ON b.payment_id = pay.id;

## Optimization_report.md

Report
Original Query
- Joined 4 tables without filtering
- Execution time: ~2.5s

Refactored Query
- Added WHERE clause to limit date range
- Used indexed columns for joins
- Execution time: ~0.6s

Conclusion
Refactoring and indexing reduced execution time by over 75%.

## Partitioning.sql

-- Partitioning Booking table by start_date (example using PostgreSQL)
CREATE TABLE bookings_partitioned (
    id SERIAL,
    user_id INT,
    property_id INT,
    start_date DATE,
    ...
) PARTITION BY RANGE (start_date);

-- Example partitions
CREATE TABLE bookings_2025 PARTITION OF bookings_partitioned
FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');

## Partition_performance.md

Report
Before Partitioning
- Query on bookings by date range took ~1.8s

After Partitioning
- Same query on partitioned table took ~0.5s

Summary
Partitioning improved performance for date-based queries.

## Performance_monitoring.md

Report
 Tools Used
- `EXPLAIN ANALYZE`
- `SHOW PROFILE`

 Bottlenecks Found
- Unindexed joins
- Large scans on `bookings`

 Actions Taken
- Added indexes
- Partitioned large tables
- Refactored queries

Result
- Reduced query times by 60â€“80%
